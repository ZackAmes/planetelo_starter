{"version":3,"sources":["../src/index.ts","../src/convertQuerytoClause.ts","../src/convertQueryToEntityKeyClauses.ts","../src/parseEntities.ts","../src/getEntities.ts","../src/getEventMessages.ts","../src/subscribeEntityQuery.ts","../src/subscribeEventQuery.ts","../src/state/zustand.ts"],"sourcesContent":["import * as torii from \"@dojoengine/torii-client\";\nimport { Account, Signature, StarknetDomain, TypedData } from \"starknet\";\n\nimport { getEntities } from \"./getEntities\";\nimport { getEventMessages } from \"./getEventMessages\";\nimport { subscribeEntityQuery } from \"./subscribeEntityQuery\";\nimport { subscribeEventQuery } from \"./subscribeEventQuery\";\nimport { SchemaType, SDK, SDKConfig, UnionOfModelData } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./state\";\n\n/**\n * Creates a new Torii client instance.\n *\n * @param {torii.ClientConfig} config - The configuration object for the Torii client.\n * @returns {Promise<torii.ToriiClient>} - A promise that resolves to the Torii client instance.\n */\nexport async function createClient(\n    config: torii.ClientConfig\n): Promise<torii.ToriiClient> {\n    return await torii.createClient(config);\n}\n\n/**\n * Initializes the SDK with the provided configuration and schema.\n *\n * @template T - The schema type.\n * @param {torii.ClientConfig} options - The configuration object for the Torii client.\n * @param {T} schema - The schema object defining the structure of the data.\n * @returns {Promise<SDK<T>>} - A promise that resolves to the initialized SDK.\n */\nexport async function init<T extends SchemaType>(\n    options: SDKConfig,\n    schema: T\n): Promise<SDK<T>> {\n    const client = await createClient(options.client);\n\n    return {\n        client,\n        /**\n         * Subscribes to entity queries.\n         *\n         * @param {SubscriptionQueryType<T>} query - The query object used to filter entities.\n         * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n         * @param {{ logging?: boolean }} [options] - Optional settings.\n         * @returns {Promise<void>} - A promise that resolves when the subscription is set up.\n         */\n        subscribeEntityQuery: (query, callback, options) =>\n            subscribeEntityQuery(client, query, schema, callback, options),\n        /**\n         * Subscribes to event queries.\n         *\n         * @param {SubscriptionQueryType<T>} query - The query object used to filter events.\n         * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n         * @param {{ logging?: boolean }} [options] - Optional settings.\n         * @returns {Promise<void>} - A promise that resolves when the subscription is set up.\n         */\n        subscribeEventQuery: (query, callback, options) =>\n            subscribeEventQuery(client, query, schema, callback, options),\n        /**\n         * Fetches entities based on the provided query.\n         *\n         * @param {SubscriptionQueryType<T>} query - The query object used to filter entities.\n         * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n         * @param {number} [limit=100] - The maximum number of entities to fetch per request. Default is 100.\n         * @param {number} [offset=0] - The offset to start fetching entities from. Default is 0.\n         * @param {{ logging?: boolean }} [options] - Optional settings.\n         * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n         */\n        getEntities: (query, callback, limit, offset, options) =>\n            getEntities(\n                client,\n                query,\n                schema,\n                callback,\n                limit,\n                offset,\n                options\n            ),\n        /**\n         * Fetches event messages based on the provided query.\n         *\n         * @param {SubscriptionQueryType<T>} query - The query object used to filter event messages.\n         * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n         * @param {number} [limit=100] - The maximum number of event messages to fetch per request. Default is 100.\n         * @param {number} [offset=0] - The offset to start fetching event messages from. Default is 0.\n         * @param {{ logging?: boolean }} [options] - Optional settings.\n         * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n         */\n        getEventMessages: (query, callback, limit, offset, options) =>\n            getEventMessages(\n                client,\n                query,\n                schema,\n                callback,\n                limit,\n                offset,\n                options\n            ),\n\n        /**\n         * Generates typed data for any user-defined message.\n         *\n         * @template M - The message type defined by the schema models.\n         * @param {string} primaryType - The primary type of the message.\n         * @param {M} message - The user-defined message content, must be part of the schema models.\n         * @param {StarknetDomain} [domain] - The domain object. If not provided, uses the default domain from options.\n         * @returns {TypedData} - The generated typed data.\n         */\n        generateTypedData: <M extends UnionOfModelData<T>>(\n            primaryType: string,\n            message: M,\n            domain: StarknetDomain = options.domain\n        ): TypedData => ({\n            types: {\n                StarknetDomain: [\n                    { name: \"name\", type: \"shortstring\" },\n                    { name: \"version\", type: \"shortstring\" },\n                    { name: \"chainId\", type: \"shortstring\" },\n                    { name: \"revision\", type: \"shortstring\" },\n                ],\n                [primaryType]: Object.keys(message).map((key) => ({\n                    name: key,\n                    type:\n                        typeof message[key] === \"bigint\" ||\n                        typeof message[key] === \"number\"\n                            ? \"felt\"\n                            : \"string\",\n                })),\n            },\n            primaryType,\n            domain,\n            message,\n        }),\n\n        /**\n         * Sends a signed message.\n         *\n         * @param {TypedData} data - The typed data to be signed and sent.\n         * @param {Account} account - The account used to sign the message.\n         * @returns {Promise<void>} - A promise that resolves when the message is sent successfully.\n         * @throws {Error} If the message sending fails.\n         */\n        sendMessage: async (\n            data: TypedData,\n            account: Account\n        ): Promise<void> => {\n            try {\n                // Sign the typed data\n                const signature: Signature = await account.signMessage(data);\n\n                // Stringify typed data for publishing\n                const dataString = JSON.stringify(data);\n                // Publish the signed message\n                await client.publishMessage(\n                    dataString,\n                    Array.isArray(signature)\n                        ? signature\n                        : [signature.r.toString(), signature.s.toString()]\n                );\n            } catch (error) {\n                console.error(\"Failed to send message:\", error);\n                throw error;\n            }\n        },\n    };\n}\n","// packages/sdk/src/convertQuerytoClause.ts\n\nimport * as torii from \"@dojoengine/torii-client\";\nimport { QueryType, SchemaType, SubscriptionQueryType } from \"./types\";\nimport { convertQueryToEntityKeyClauses } from \"./convertQueryToEntityKeyClauses\";\n\n/**\n * Converts a query object into a Torii clause.\n *\n * @template T - The schema type.\n * @param {QueryType<T>} query - The query object to convert.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.Clause | undefined} - The resulting Torii clause or undefined.\n */\nexport function convertQueryToClause<T extends SchemaType>(\n    query: QueryType<T>,\n    schema: T\n): torii.Clause | undefined {\n    const clauses: torii.Clause[] = [];\n\n    for (const [namespace, models] of Object.entries(query)) {\n        if (namespace === \"entityIds\") continue; // Skip entityIds\n\n        if (models && typeof models === \"object\") {\n            const modelClauses = processModels(namespace, models, schema);\n            if (modelClauses.length > 0) {\n                clauses.push(...modelClauses);\n            }\n        }\n    }\n\n    // If there are clauses, combine them under a single Composite clause\n    if (clauses.length > 1) {\n        return {\n            Composite: {\n                operator: \"Or\",\n                clauses: clauses,\n            },\n        };\n    } else if (clauses.length === 1) {\n        return clauses[0];\n    }\n\n    // If there are no clauses, return undefined\n    return undefined;\n}\n\n/**\n * Processes all models within a namespace and generates corresponding clauses.\n *\n * @template T - The schema type.\n * @param {string} namespace - The namespace of the models.\n * @param {any} models - The models object to process.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.Clause[]} - An array of generated clauses.\n */\nfunction processModels<T extends SchemaType>(\n    namespace: string,\n    models: any,\n    schema: T\n): torii.Clause[] {\n    const clauses: torii.Clause[] = [];\n\n    for (const [model, modelData] of Object.entries(models)) {\n        const namespaceModel = `${namespace}-${model}`;\n\n        if (modelData && typeof modelData === \"object\" && \"$\" in modelData) {\n            const conditions = modelData.$ as Record<string, unknown>;\n            if (\n                conditions &&\n                typeof conditions === \"object\" &&\n                \"where\" in conditions\n            ) {\n                const whereClause = conditions.where;\n                if (whereClause && typeof whereClause === \"object\") {\n                    // Iterate over each member in the whereClause to handle $is\n                    for (const [member, memberConditions] of Object.entries(\n                        whereClause\n                    )) {\n                        if (\n                            typeof memberConditions === \"object\" &&\n                            memberConditions !== null &&\n                            \"$is\" in memberConditions\n                        ) {\n                            // Convert $is to EntityKeysClause\n                            const isClauses = convertQueryToEntityKeyClauses(\n                                {\n                                    [namespace]: {\n                                        [model]: {\n                                            $: {\n                                                where: {\n                                                    [member]: {\n                                                        $is: memberConditions[\n                                                            \"$is\"\n                                                        ],\n                                                    },\n                                                },\n                                            },\n                                        },\n                                    },\n                                } as SubscriptionQueryType<T>,\n                                schema\n                            );\n                            clauses.push(...(isClauses as any));\n\n                            // Remove $is from memberConditions to prevent further processing\n                            const { $is, ...remainingConditions } =\n                                memberConditions;\n                            (whereClause as Record<string, unknown>)[member] =\n                                remainingConditions;\n                        }\n                    }\n\n                    // After handling all $is, build the remaining whereClause\n                    const clause = buildWhereClause(\n                        namespaceModel,\n                        whereClause\n                    );\n                    if (clause) {\n                        if (\n                            \"Composite\" in clause &&\n                            clause.Composite.operator === \"And\"\n                        ) {\n                            // If the composite operator is \"And\", flatten the clauses\n                            clauses.push(...clause.Composite.clauses);\n                        } else {\n                            // Otherwise, keep the composite as is to preserve logical structure\n                            clauses.push(clause);\n                        }\n                    }\n                }\n            }\n        } else {\n            // Handle the case where there are no conditions\n            clauses.push({\n                Keys: {\n                    keys: [undefined],\n                    pattern_matching: \"FixedLen\",\n                    models: [namespaceModel],\n                },\n            });\n        }\n    }\n\n    return clauses;\n}\n\n/**\n * Builds a Torii clause from a where clause object.\n *\n * @param {string} namespaceModel - The namespaced model identifier.\n * @param {Record<string, any>} where - The where clause conditions.\n * @returns {torii.Clause | undefined} - The constructed Torii clause or undefined.\n */\nfunction buildWhereClause(\n    namespaceModel: string,\n    where: Record<string, any>\n): torii.Clause | undefined {\n    // Define logical operator mapping\n    const logicalOperators: Record<string, torii.LogicalOperator> = {\n        And: \"And\",\n        Or: \"Or\",\n    };\n\n    // Check for logical operators first\n    const keys = Object.keys(where);\n    const logicalKey = keys.find((key) => key in logicalOperators);\n\n    if (logicalKey) {\n        const operator = logicalOperators[logicalKey];\n        const conditions = where[logicalKey] as Array<Record<string, any>>;\n\n        const subClauses: torii.Clause[] = [];\n\n        for (const condition of conditions) {\n            const clause = buildWhereClause(namespaceModel, condition);\n            if (clause) {\n                subClauses.push(clause);\n            }\n        }\n\n        if (subClauses.length === 1) {\n            return subClauses[0];\n        }\n\n        return {\n            Composite: {\n                operator: operator,\n                clauses: subClauses,\n            },\n        };\n    }\n\n    // If no logical operator, build Member clauses\n    const memberClauses: torii.Clause[] = [];\n\n    for (const [member, memberValue] of Object.entries(where)) {\n        if (typeof memberValue === \"object\" && memberValue !== null) {\n            const memberKeys = Object.keys(memberValue);\n            // Check if memberValue contains logical operators\n            const memberLogicalKey = memberKeys.find(\n                (key) => key in logicalOperators\n            );\n            if (memberLogicalKey) {\n                const operator = logicalOperators[memberLogicalKey];\n                const conditions = memberValue[memberLogicalKey] as Array<\n                    Record<string, any>\n                >;\n\n                const nestedClauses: torii.Clause[] = [];\n                for (const condition of conditions) {\n                    const clause = buildWhereClause(namespaceModel, condition);\n                    if (clause) {\n                        nestedClauses.push(clause);\n                    }\n                }\n\n                if (nestedClauses.length === 1) {\n                    memberClauses.push(nestedClauses[0]);\n                } else {\n                    memberClauses.push({\n                        Composite: {\n                            operator: operator,\n                            clauses: nestedClauses,\n                        },\n                    });\n                }\n            } else {\n                // Process operators like $eq, $gt, etc\n                for (const [op, val] of Object.entries(memberValue)) {\n                    memberClauses.push({\n                        Member: {\n                            model: namespaceModel,\n                            member,\n                            operator: convertOperator(op),\n                            value: convertToPrimitive(val),\n                        },\n                    });\n                }\n            }\n        } else {\n            // Assume equality condition\n            memberClauses.push({\n                Member: {\n                    model: namespaceModel,\n                    member,\n                    operator: \"Eq\",\n                    value: convertToPrimitive(memberValue),\n                },\n            });\n        }\n    }\n\n    if (memberClauses.length === 1) {\n        return memberClauses[0];\n    } else if (memberClauses.length > 1) {\n        return {\n            Composite: {\n                operator: \"And\",\n                clauses: memberClauses,\n            },\n        };\n    }\n\n    return undefined;\n}\n\n/**\n * Converts a value to a Torii primitive type.\n *\n * @param {any} value - The value to convert.\n * @returns {torii.MemberValue} - The converted primitive value.\n * @throws {Error} - If the value type is unsupported.\n */\nfunction convertToPrimitive(value: any): torii.MemberValue {\n    if (typeof value === \"number\") {\n        return { Primitive: { U32: value } };\n    } else if (typeof value === \"boolean\") {\n        return { Primitive: { Bool: value } };\n    } else if (typeof value === \"bigint\") {\n        return {\n            Primitive: {\n                Felt252: torii.cairoShortStringToFelt(value.toString()),\n            },\n        };\n    } else if (typeof value === \"string\") {\n        return { String: value };\n    }\n\n    // Add more type conversions as needed\n    throw new Error(`Unsupported primitive type: ${typeof value}`);\n}\n\n/**\n * Converts a query operator to a Torii comparison operator.\n *\n * @param {string} operator - The query operator to convert.\n * @returns {torii.ComparisonOperator} - The corresponding Torii comparison operator.\n * @throws {Error} - If the operator is unsupported.\n */\nfunction convertOperator(operator: string): torii.ComparisonOperator {\n    console.log(operator);\n    switch (operator) {\n        case \"$eq\":\n            return \"Eq\";\n        case \"$neq\":\n            return \"Neq\";\n        case \"$gt\":\n            return \"Gt\";\n        case \"$gte\":\n            return \"Gte\";\n        case \"$lt\":\n            return \"Lt\";\n        case \"$lte\":\n            return \"Lte\";\n        default:\n            throw new Error(`Unsupported operator: ${operator}`);\n    }\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { SchemaType, SubscriptionQueryType } from \"./types\";\n\n/**\n * Converts a subscription query to an array of EntityKeysClause.\n *\n * @template T - The schema type.\n * @param {SubscriptionQueryType<T>} query - The subscription query to convert.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.EntityKeysClause[]} An array of EntityKeysClause.\n */\nexport function convertQueryToEntityKeyClauses<T extends SchemaType>(\n    query: SubscriptionQueryType<T>,\n    schema: T\n): torii.EntityKeysClause[] {\n    if (!query) {\n        return [];\n    }\n\n    const clauses: torii.EntityKeysClause[] = [];\n\n    const { entityIds, ...namespaces } = query;\n\n    if (entityIds && entityIds.length > 0) {\n        clauses.push({ HashedKeys: entityIds });\n    }\n\n    clauses.push(...convertQueryToKeysClause(namespaces, schema));\n\n    return clauses;\n}\n\n/**\n * Converts namespaces to an array of EntityKeysClause.\n *\n * @template T - The schema type.\n * @param {Omit<SubscriptionQueryType<T>, \"entityIds\">} namespaces - The namespaces to convert.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.EntityKeysClause[]} An array of EntityKeysClause.\n */\nexport function convertQueryToKeysClause<T extends SchemaType>(\n    namespaces: Omit<SubscriptionQueryType<T>, \"entityIds\">,\n    schema: T\n): torii.EntityKeysClause[] {\n    const clauses: torii.EntityKeysClause[] = [];\n\n    Object.entries(namespaces).forEach(([namespace, models]) => {\n        if (models && typeof models === \"object\") {\n            Object.entries(models).forEach(([model, value]) => {\n                const namespaceModel = `${namespace}-${model}`;\n                if (Array.isArray(value)) {\n                    const clause = createClause(namespaceModel, value);\n                    if (clause) {\n                        clauses.push(clause);\n                    }\n                } else if (\n                    typeof value === \"object\" &&\n                    value !== null &&\n                    \"$\" in value\n                ) {\n                    const whereOptions = (value as { $: { where: any } }).$\n                        .where;\n                    const modelSchema = schema[namespace]?.[model];\n                    if (modelSchema) {\n                        const clause = createClauseFromWhere(\n                            namespaceModel,\n                            whereOptions,\n                            modelSchema.fieldOrder\n                        );\n                        if (clause) {\n                            clauses.push(clause);\n                        }\n                    }\n                }\n            });\n        }\n    });\n\n    return clauses;\n}\n\n/**\n * Creates an EntityKeysClause based on the provided model and value.\n *\n * @param {string} namespaceModel - The combined namespace and model string.\n * @param {string[]} value - The value associated with the model.\n * @returns {torii.EntityKeysClause | undefined} An EntityKeysClause or undefined.\n */\nfunction createClause(\n    namespaceModel: string,\n    value: string[]\n): torii.EntityKeysClause | undefined {\n    if (Array.isArray(value) && value.length === 0) {\n        return {\n            Keys: {\n                keys: [undefined],\n                pattern_matching: \"VariableLen\",\n                models: [namespaceModel],\n            },\n        };\n    } else if (Array.isArray(value)) {\n        return {\n            Keys: {\n                keys: value,\n                pattern_matching: \"FixedLen\",\n                models: [namespaceModel],\n            },\n        };\n    }\n    return undefined;\n}\n\n/**\n * Creates an EntityKeysClause based on the provided where conditions.\n * Orders the keys array based on the fieldOrder from the schema,\n * inserting undefined placeholders where necessary.\n *\n * @param {string} namespaceModel - The combined namespace and model string.\n * @param {Record<string, { $is?: any; $eq?: any; $neq?: any; $gt?: any; $gte?: any; $lt?: any; $lte?: any }>} [whereOptions] - The where conditions from the query.\n * @param {string[]} [fieldOrder=[]] - The defined order of fields for the model.\n * @returns {torii.EntityKeysClause | undefined} An EntityKeysClause or undefined.\n */\nfunction createClauseFromWhere(\n    namespaceModel: string,\n    whereOptions?: Record<\n        string,\n        {\n            $is?: any;\n            $eq?: any;\n            $neq?: any;\n            $gt?: any;\n            $gte?: any;\n            $lt?: any;\n            $lte?: any;\n        }\n    >,\n    fieldOrder: string[] = []\n): torii.EntityKeysClause | undefined {\n    if (!whereOptions || Object.keys(whereOptions).length === 0) {\n        return {\n            Keys: {\n                keys: Array(fieldOrder.length).fill(undefined),\n                pattern_matching: \"VariableLen\",\n                models: [namespaceModel],\n            },\n        };\n    }\n\n    // Initialize keys array with undefined placeholders\n    const keys: (string | undefined)[] = Array(fieldOrder.length).fill(\n        undefined\n    );\n\n    Object.entries(whereOptions).forEach(([field, condition]) => {\n        // Find the index of the field in the fieldOrder\n        const index = fieldOrder.indexOf(field);\n        if (index !== -1) {\n            // Assign value without operator prefixes\n            if (condition.$is !== undefined) {\n                keys[index] = condition.$is.toString();\n            }\n            if (condition.$eq !== undefined) {\n                keys[index] = condition.$eq.toString();\n            }\n            if (condition.$neq !== undefined) {\n                keys[index] = condition.$neq.toString();\n            }\n            if (condition.$gt !== undefined) {\n                keys[index] = condition.$gt.toString();\n            }\n            if (condition.$gte !== undefined) {\n                keys[index] = condition.$gte.toString();\n            }\n            if (condition.$lt !== undefined) {\n                keys[index] = condition.$lt.toString();\n            }\n            if (condition.$lte !== undefined) {\n                keys[index] = condition.$lte.toString();\n            }\n            // Add more operators as needed\n        }\n    });\n\n    console.log(\"fieldOrder\", keys);\n\n    return {\n        Keys: {\n            keys: keys,\n            pattern_matching: \"VariableLen\",\n            models: [namespaceModel],\n        },\n    };\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { ParsedEntity, SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Parses a collection of entities into a standardized query result format.\n *\n * @template T - The schema type.\n * @param {torii.Entities} entities - The collection of entities to parse.\n * @param {{ logging?: boolean }} [options] - Optional settings for logging.\n * @returns {StandardizedQueryResult<T>} - The parsed entities in a standardized query result format.\n *\n * @example\n * const parsedResult = parseEntities(entities, { logging: true });\n * console.log(parsedResult);\n */\nexport function parseEntities<T extends SchemaType>(\n    entities: torii.Entities,\n    options?: { logging?: boolean }\n): StandardizedQueryResult<T> {\n    const result: StandardizedQueryResult<T> = [];\n\n    for (const entityId in entities) {\n        const entityData = entities[entityId];\n        const parsedEntity: ParsedEntity<T> = {\n            entityId,\n            models: {} as ParsedEntity<T>[\"models\"],\n        };\n\n        for (const modelName in entityData) {\n            const [schemaKey, modelKey] = modelName.split(\"-\") as [\n                keyof T,\n                string,\n            ];\n\n            if (!schemaKey || !modelKey) {\n                if (options?.logging) {\n                    console.warn(`Invalid modelName format: ${modelName}`);\n                }\n                continue;\n            }\n\n            if (!parsedEntity.models[schemaKey]) {\n                parsedEntity.models[schemaKey] = {} as T[typeof schemaKey];\n            }\n\n            (parsedEntity.models[schemaKey] as any)[modelKey] = parseStruct(\n                entityData[modelName]\n            );\n        }\n\n        result.push(parsedEntity);\n\n        if (options?.logging) {\n            console.log(`Parsed entity:`, parsedEntity);\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"Parsed result:\", result);\n    }\n\n    return result;\n}\n\n/**\n * Parses a value based on its type.\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {any} - The parsed value.\n */\nfunction parseValue(value: torii.Ty): any {\n    switch (value.type) {\n        case \"primitive\":\n            return value.value;\n        case \"struct\":\n            return parseStruct(\n                value.value as Record<string, torii.Ty> | Map<string, torii.Ty>\n            );\n        case \"enum\":\n            return (value.value as torii.EnumValue).option;\n        case \"array\":\n            return (value.value as torii.Ty[]).map(parseValue);\n        default:\n            return value.value;\n    }\n}\n\n/**\n * Parses a struct (record or map) into an object with parsed values.\n *\n * @param {Record<string, torii.Ty> | Map<string, torii.Ty>} struct - The struct to parse.\n * @returns {any} - The parsed struct as an object.\n */\nfunction parseStruct(\n    struct: Record<string, torii.Ty> | Map<string, torii.Ty>\n): any {\n    const entries =\n        struct instanceof Map\n            ? Array.from(struct.entries())\n            : Object.entries(struct);\n    return Object.fromEntries(\n        entries.map(([key, value]) => [key, parseValue(value)])\n    );\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToClause } from \"./convertQuerytoClause\";\nimport { parseEntities } from \"./parseEntities\";\nimport { QueryType, SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Fetches entities from the Torii client based on the provided query.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance used to fetch entities.\n * @param {QueryType<T>} query - The query object used to filter entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n * @param {number} [limit=100] - The maximum number of entities to fetch per request. Default is 100.\n * @param {number} [offset=0] - The offset to start fetching entities from. Default is 0.\n * @param {{ logging?: boolean }} [options] - Optional settings.\n * @param {boolean} [options.logging] - If true, enables logging of the fetching process. Default is false.\n * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n *\n * @example\n * const result = await getEntities(client, query, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, 100, 0, { logging: true });\n */\nexport async function getEntities<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: QueryType<T>,\n    schema: T,\n    callback: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    limit: number = 100, // Default limit\n    offset: number = 0, // Default offset\n    options?: { logging?: boolean } // Logging option\n): Promise<StandardizedQueryResult<T>> {\n    const clause = convertQueryToClause(query, schema);\n\n    let cursor = offset;\n    let continueFetching = true;\n    let allEntities: torii.Entities = {};\n\n    while (continueFetching) {\n        const toriiQuery: torii.Query = {\n            limit: limit,\n            offset: cursor,\n            clause,\n            dont_include_hashed_keys: false,\n        };\n\n        try {\n            const entities = await client.getEntities(toriiQuery);\n\n            if (options?.logging) {\n                console.log(\"Clause\", clause, \"Query\", query);\n                console.log(`Fetched entities at offset ${cursor}:`, entities);\n            }\n\n            Object.assign(allEntities, entities);\n\n            const parsedEntities = parseEntities<T>(allEntities);\n\n            callback({ data: parsedEntities });\n\n            if (Object.keys(entities).length < limit) {\n                continueFetching = false;\n            } else {\n                cursor += limit;\n            }\n        } catch (error) {\n            if (options?.logging) {\n                console.error(\"Error fetching entities:\", error);\n            }\n            callback({ error: error as Error });\n            throw error;\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"All fetched entities:\", allEntities);\n    }\n    return parseEntities<T>(allEntities);\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToClause } from \"./convertQuerytoClause\";\nimport { parseEntities } from \"./parseEntities\";\nimport { QueryType, SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Fetches event messages from the Torii client based on the provided query.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance used to fetch event messages.\n * @param {QueryType<T>} query - The query object used to filter event messages.\n * @param {T} schema - The schema type for the entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n * @param {number} [limit=100] - The maximum number of event messages to fetch per request. Default is 100.\n * @param {number} [offset=0] - The offset to start fetching event messages from. Default is 0.\n * @param {{ logging?: boolean }} [options] - Optional settings.\n * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n *\n * @example\n * const eventMessages = await getEventMessages(client, query, schema, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, 100, 0, { logging: true });\n */\nexport async function getEventMessages<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: QueryType<T>,\n    schema: T,\n    callback: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    limit: number = 100, // Default limit\n    offset: number = 0, // Default offset\n    options?: { logging?: boolean } // Logging option\n): Promise<StandardizedQueryResult<T>> {\n    const clause = convertQueryToClause(query, schema);\n\n    let cursor = offset;\n    let continueFetching = true;\n    let allEntities: torii.Entities = {};\n\n    while (continueFetching) {\n        const toriiQuery: torii.Query = {\n            limit: limit,\n            offset: cursor,\n            clause,\n            dont_include_hashed_keys: false,\n        };\n\n        try {\n            const entities = await client.getEventMessages(toriiQuery, true);\n\n            if (options?.logging) {\n                console.log(`Fetched entities at offset ${cursor}:`, entities);\n            }\n\n            Object.assign(allEntities, entities);\n\n            const parsedEntities = parseEntities<T>(allEntities);\n\n            callback({ data: parsedEntities });\n\n            if (Object.keys(entities).length < limit) {\n                continueFetching = false;\n            } else {\n                cursor += limit;\n            }\n        } catch (error) {\n            if (options?.logging) {\n                console.error(\"Error fetching entities:\", error);\n            }\n            callback({ error: error as Error });\n            throw error;\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"All fetched entities:\", allEntities);\n    }\n    return parseEntities<T>(allEntities);\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToEntityKeyClauses } from \"./convertQueryToEntityKeyClauses\";\nimport { parseEntities } from \"./parseEntities\";\nimport {\n    SchemaType,\n    StandardizedQueryResult,\n    SubscriptionQueryType,\n} from \"./types\";\n\n/**\n * Subscribes to entity updates based on the provided query and invokes the callback with the updated data.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance.\n * @param {SubscriptionQueryType<T>} query - The subscription query to filter the entities.\n * @param {T} schema - The schema type for the entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} [callback] - The callback function to handle the response.\n * @param {{ logging?: boolean }} [options] - Optional settings for the subscription.\n * @returns {Promise<torii.Subscription>} - A promise that resolves to a Torii subscription.\n *\n * @example\n * const subscription = await subscribeEntityQuery(client, query, schema, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, { logging: true });\n */\nexport async function subscribeEntityQuery<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: SubscriptionQueryType<T>,\n    schema: T,\n    callback?: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    options?: { logging?: boolean }\n): Promise<torii.Subscription> {\n    if (options?.logging) {\n        console.log(\"Query:\", query);\n        console.log(\n            \"convertQueryToEntityKeyClauses:\",\n            convertQueryToEntityKeyClauses(query, schema)\n        );\n    }\n    return client.onEntityUpdated(\n        convertQueryToEntityKeyClauses(query, schema),\n        (entityId: string, entityData: any) => {\n            try {\n                if (callback) {\n                    const parsedData = parseEntities<T>({\n                        [entityId]: entityData,\n                    });\n                    if (options?.logging) {\n                        console.log(\n                            \"Converted query to entity key clauses:\",\n                            convertQueryToEntityKeyClauses(query, schema)\n                        );\n                        console.log(\"Parsed entity data:\", parsedData);\n                    }\n                    callback({ data: parsedData });\n                }\n            } catch (error) {\n                if (callback) {\n                    if (options?.logging) {\n                        console.error(\"Error parsing entity data:\", error);\n                    }\n                    callback({\n                        error:\n                            error instanceof Error\n                                ? error\n                                : new Error(String(error)),\n                    });\n                }\n            }\n        }\n    );\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToEntityKeyClauses } from \"./convertQueryToEntityKeyClauses\";\nimport { parseEntities } from \"./parseEntities\";\nimport {\n    SchemaType,\n    StandardizedQueryResult,\n    SubscriptionQueryType,\n} from \"./types\";\n\n/**\n * Subscribes to event messages based on the provided query and invokes the callback with the updated data.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance.\n * @param {SubscriptionQueryType<T>} query - The subscription query to filter the events.\n * @param {T} schema - The schema type for the entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} [callback] - The callback function to handle the response.\n * @param {{ logging?: boolean }} [options] - Optional settings for the subscription.\n * @returns {Promise<torii.Subscription>} - A promise that resolves to a Torii subscription.\n *\n * @example\n * const subscription = await subscribeEventQuery(client, query, schema, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, { logging: true });\n */\nexport async function subscribeEventQuery<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: SubscriptionQueryType<T>,\n    schema: T,\n    callback?: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    options?: { logging?: boolean }\n): Promise<torii.Subscription> {\n    return client.onEventMessageUpdated(\n        convertQueryToEntityKeyClauses(query, schema),\n        true,\n        (entityId: string, entityData: any) => {\n            try {\n                if (callback) {\n                    const parsedData = parseEntities<T>({\n                        [entityId]: entityData,\n                    });\n                    if (options?.logging) {\n                        console.log(\"Parsed entity data:\", parsedData);\n                    }\n                    callback({ data: parsedData });\n                }\n            } catch (error) {\n                if (callback) {\n                    if (options?.logging) {\n                        console.error(\"Error parsing entity data:\", error);\n                    }\n                    callback({\n                        error:\n                            error instanceof Error\n                                ? error\n                                : new Error(String(error)),\n                    });\n                }\n            }\n        }\n    );\n}\n","import { create } from \"zustand\";\nimport { immer } from \"zustand/middleware/immer\";\nimport {\n    Draft,\n    Patch,\n    WritableDraft,\n    applyPatches,\n    produceWithPatches,\n} from \"immer\";\n\nimport { enablePatches } from \"immer\";\nimport { subscribeWithSelector } from \"zustand/middleware\";\nimport { ParsedEntity, SchemaType } from \"../types\";\n\nenablePatches();\n\ninterface PendingTransaction {\n    transactionId: string;\n    patches: Patch[];\n    inversePatches: Patch[];\n}\n\ninterface GameState<T extends SchemaType> {\n    entities: Record<string, ParsedEntity<T>>;\n    pendingTransactions: Record<string, PendingTransaction>;\n    setEntities: (entities: ParsedEntity<T>[]) => void;\n    updateEntity: (entity: Partial<ParsedEntity<T>>) => void;\n    applyOptimisticUpdate: (\n        transactionId: string,\n        updateFn: (draft: Draft<GameState<T>>) => void\n    ) => void;\n    revertOptimisticUpdate: (transactionId: string) => void;\n    confirmTransaction: (transactionId: string) => void;\n    subscribeToEntity: (\n        entityId: string,\n        listener: (entity: ParsedEntity<T> | undefined) => void\n    ) => () => void;\n    waitForEntityChange: (\n        entityId: string,\n        predicate: (entity: ParsedEntity<T> | undefined) => boolean,\n        timeout?: number\n    ) => Promise<ParsedEntity<T> | undefined>;\n    getEntity: (entityId: string) => ParsedEntity<T> | undefined;\n    getEntities: (\n        filter?: (entity: ParsedEntity<T>) => boolean\n    ) => ParsedEntity<T>[];\n    getEntitiesByModel: (\n        namespace: keyof T,\n        model: keyof T[keyof T]\n    ) => ParsedEntity<T>[];\n}\n\n/**\n * Factory function to create a Zustand store based on a given SchemaType.\n *\n * @template T - The schema type.\n * @returns A Zustand hook tailored to the provided schema.\n */\nexport function createDojoStore<T extends SchemaType>() {\n    const useStore = create<GameState<T>>()(\n        subscribeWithSelector(\n            immer((set, get) => ({\n                entities: {},\n                pendingTransactions: {},\n                setEntities: (entities: ParsedEntity<T>[]) => {\n                    set((state: Draft<GameState<T>>) => {\n                        entities.forEach((entity) => {\n                            state.entities[entity.entityId] =\n                                entity as WritableDraft<ParsedEntity<T>>;\n                        });\n                    });\n                },\n                updateEntity: (entity: Partial<ParsedEntity<T>>) => {\n                    set((state: Draft<GameState<T>>) => {\n                        if (\n                            entity.entityId &&\n                            state.entities[entity.entityId] &&\n                            entity.models\n                        ) {\n                            const existingEntity =\n                                state.entities[entity.entityId];\n\n                            // Create new models object without spread\n                            const mergedModels: typeof existingEntity.models =\n                                Object.assign({}, existingEntity.models);\n\n                            // Iterate through each namespace in the new models\n                            Object.entries(entity.models).forEach(\n                                ([namespace, namespaceModels]) => {\n                                    const typedNamespace =\n                                        namespace as keyof ParsedEntity<T>[\"models\"];\n                                    if (!(typedNamespace in mergedModels)) {\n                                        mergedModels[\n                                            typedNamespace as keyof typeof mergedModels\n                                        ] = {} as any;\n                                    }\n\n                                    mergedModels[\n                                        typedNamespace as keyof typeof mergedModels\n                                    ] = Object.assign(\n                                        {},\n                                        mergedModels[\n                                            typedNamespace as keyof typeof mergedModels\n                                        ],\n                                        namespaceModels\n                                    );\n                                }\n                            );\n                            // Update the entity\n                            state.entities[entity.entityId] = {\n                                ...existingEntity,\n                                ...entity,\n                                models: mergedModels,\n                            };\n                        }\n                    });\n                },\n                applyOptimisticUpdate: (transactionId, updateFn) => {\n                    const currentState = get();\n                    const [nextState, patches, inversePatches] =\n                        produceWithPatches(\n                            currentState,\n                            (draftState: Draft<GameState<T>>) => {\n                                updateFn(draftState);\n                            }\n                        );\n\n                    set(() => nextState);\n\n                    set((state: Draft<GameState<T>>) => {\n                        state.pendingTransactions[transactionId] = {\n                            transactionId,\n                            patches,\n                            inversePatches,\n                        };\n                    });\n                },\n                revertOptimisticUpdate: (transactionId) => {\n                    const transaction =\n                        get().pendingTransactions[transactionId];\n                    if (transaction) {\n                        set((state: Draft<GameState<T>>) =>\n                            applyPatches(state, transaction.inversePatches)\n                        );\n                        set((state: Draft<GameState<T>>) => {\n                            delete state.pendingTransactions[transactionId];\n                        });\n                    }\n                },\n                confirmTransaction: (transactionId) => {\n                    set((state: Draft<GameState<T>>) => {\n                        delete state.pendingTransactions[transactionId];\n                    });\n                },\n                subscribeToEntity: (entityId, listener): (() => void) => {\n                    return useStore.subscribe((state) => {\n                        const entity = state.entities[entityId];\n                        listener(entity);\n                    });\n                },\n                waitForEntityChange: (entityId, predicate, timeout = 6000) => {\n                    return new Promise<ParsedEntity<T> | undefined>(\n                        (resolve, reject) => {\n                            const unsubscribe = useStore.subscribe(\n                                (state) => state.entities[entityId],\n                                (entity) => {\n                                    if (predicate(entity)) {\n                                        clearTimeout(timer);\n                                        unsubscribe();\n                                        resolve(entity);\n                                    }\n                                }\n                            );\n\n                            const timer = setTimeout(() => {\n                                unsubscribe();\n                                reject(\n                                    new Error(\n                                        `waitForEntityChange: Timeout of ${timeout}ms exceeded`\n                                    )\n                                );\n                            }, timeout);\n                        }\n                    );\n                },\n                // Implementing query layer methods\n                getEntity: (entityId: string) => {\n                    return get().entities[entityId];\n                },\n\n                getEntities: (\n                    filter?: (entity: ParsedEntity<T>) => boolean\n                ) => {\n                    const allEntities = Object.values(get().entities);\n                    return filter ? allEntities.filter(filter) : allEntities;\n                },\n\n                getEntitiesByModel: (namespace, model) => {\n                    return get().getEntities((entity) => {\n                        return !!entity.models[namespace]?.[model];\n                    });\n                },\n            }))\n        )\n    );\n\n    return useStore;\n}\n"],"mappings":"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","names":["torii","torii","convertQueryToEntityKeyClauses","query","schema","clauses","entityIds","namespaces","convertQueryToKeysClause","namespace","models","model","value","namespaceModel","clause","createClause","whereOptions","modelSchema","createClauseFromWhere","fieldOrder","keys","field","condition","index","convertQueryToClause","query","schema","clauses","namespace","models","modelClauses","processModels","model","modelData","namespaceModel","conditions","whereClause","member","memberConditions","isClauses","convertQueryToEntityKeyClauses","$is","remainingConditions","clause","buildWhereClause","where","logicalOperators","logicalKey","key","operator","subClauses","condition","memberClauses","memberValue","memberLogicalKey","nestedClauses","op","val","convertOperator","convertToPrimitive","value","parseEntities","entities","options","result","entityId","entityData","parsedEntity","modelName","schemaKey","modelKey","parseStruct","parseValue","value","struct","entries","key","getEntities","client","query","schema","callback","limit","offset","options","clause","convertQueryToClause","cursor","continueFetching","allEntities","toriiQuery","entities","parsedEntities","parseEntities","error","getEventMessages","client","query","schema","callback","limit","offset","options","clause","convertQueryToClause","cursor","continueFetching","allEntities","toriiQuery","entities","parsedEntities","parseEntities","error","subscribeEntityQuery","client","query","schema","callback","options","convertQueryToEntityKeyClauses","entityId","entityData","parsedData","parseEntities","error","subscribeEventQuery","client","query","schema","callback","options","convertQueryToEntityKeyClauses","entityId","entityData","parsedData","parseEntities","error","create","immer","applyPatches","produceWithPatches","enablePatches","subscribeWithSelector","createDojoStore","useStore","set","get","entities","state","entity","existingEntity","mergedModels","namespace","namespaceModels","typedNamespace","transactionId","updateFn","currentState","nextState","patches","inversePatches","draftState","transaction","entityId","listener","predicate","timeout","resolve","reject","unsubscribe","timer","filter","allEntities","model","createClient","config","init","options","schema","client","query","callback","subscribeEntityQuery","subscribeEventQuery","limit","offset","getEntities","getEventMessages","primaryType","message","domain","key","data","account","signature","dataString","error"]}