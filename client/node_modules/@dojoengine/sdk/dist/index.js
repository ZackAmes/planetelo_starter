import*as v from"@dojoengine/torii-client";import*as b from"@dojoengine/torii-client";function p(i,a){if(!i)return[];let o=[],{entityIds:e,...r}=i;return e&&e.length>0&&o.push({HashedKeys:e}),o.push(...x(r,a)),o}function x(i,a){let o=[];return Object.entries(i).forEach(([e,r])=>{r&&typeof r=="object"&&Object.entries(r).forEach(([t,n])=>{let s=`${e}-${t}`;if(Array.isArray(n)){let c=j(s,n);c&&o.push(c)}else if(typeof n=="object"&&n!==null&&"$"in n){let c=n.$.where,y=a[e]?.[t];if(y){let u=w(s,c,y.fieldOrder);u&&o.push(u)}}})}),o}function j(i,a){if(Array.isArray(a)&&a.length===0)return{Keys:{keys:[void 0],pattern_matching:"VariableLen",models:[i]}};if(Array.isArray(a))return{Keys:{keys:a,pattern_matching:"FixedLen",models:[i]}}}function w(i,a,o=[]){if(!a||Object.keys(a).length===0)return{Keys:{keys:Array(o.length).fill(void 0),pattern_matching:"VariableLen",models:[i]}};let e=Array(o.length).fill(void 0);return Object.entries(a).forEach(([r,t])=>{let n=o.indexOf(r);n!==-1&&(t.$is!==void 0&&(e[n]=t.$is.toString()),t.$eq!==void 0&&(e[n]=t.$eq.toString()),t.$neq!==void 0&&(e[n]=t.$neq.toString()),t.$gt!==void 0&&(e[n]=t.$gt.toString()),t.$gte!==void 0&&(e[n]=t.$gte.toString()),t.$lt!==void 0&&(e[n]=t.$lt.toString()),t.$lte!==void 0&&(e[n]=t.$lte.toString()))}),console.log("fieldOrder",e),{Keys:{keys:e,pattern_matching:"VariableLen",models:[i]}}}function T(i,a){let o=[];for(let[e,r]of Object.entries(i))if(e!=="entityIds"&&r&&typeof r=="object"){let t=D(e,r,a);t.length>0&&o.push(...t)}if(o.length>1)return{Composite:{operator:"Or",clauses:o}};if(o.length===1)return o[0]}function D(i,a,o){let e=[];for(let[r,t]of Object.entries(a)){let n=`${i}-${r}`;if(t&&typeof t=="object"&&"$"in t){let s=t.$;if(s&&typeof s=="object"&&"where"in s){let c=s.where;if(c&&typeof c=="object"){for(let[u,f]of Object.entries(c))if(typeof f=="object"&&f!==null&&"$is"in f){let d=p({[i]:{[r]:{$:{where:{[u]:{$is:f.$is}}}}}},o);e.push(...d);let{$is:m,...g}=f;c[u]=g}let y=h(n,c);y&&("Composite"in y&&y.Composite.operator==="And"?e.push(...y.Composite.clauses):e.push(y))}}}else e.push({Keys:{keys:[void 0],pattern_matching:"FixedLen",models:[n]}})}return e}function h(i,a){let o={And:"And",Or:"Or"},r=Object.keys(a).find(n=>n in o);if(r){let n=o[r],s=a[r],c=[];for(let y of s){let u=h(i,y);u&&c.push(u)}return c.length===1?c[0]:{Composite:{operator:n,clauses:c}}}let t=[];for(let[n,s]of Object.entries(a))if(typeof s=="object"&&s!==null){let y=Object.keys(s).find(u=>u in o);if(y){let u=o[y],f=s[y],d=[];for(let m of f){let g=h(i,m);g&&d.push(g)}d.length===1?t.push(d[0]):t.push({Composite:{operator:u,clauses:d}})}else for(let[u,f]of Object.entries(s))t.push({Member:{model:i,member:n,operator:K(u),value:E(f)}})}else t.push({Member:{model:i,member:n,operator:"Eq",value:E(s)}});if(t.length===1)return t[0];if(t.length>1)return{Composite:{operator:"And",clauses:t}}}function E(i){if(typeof i=="number")return{Primitive:{U32:i}};if(typeof i=="boolean")return{Primitive:{Bool:i}};if(typeof i=="bigint")return{Primitive:{Felt252:b.cairoShortStringToFelt(i.toString())}};if(typeof i=="string")return{String:i};throw new Error(`Unsupported primitive type: ${typeof i}`)}function K(i){switch(console.log(i),i){case"$eq":return"Eq";case"$neq":return"Neq";case"$gt":return"Gt";case"$gte":return"Gte";case"$lt":return"Lt";case"$lte":return"Lte";default:throw new Error(`Unsupported operator: ${i}`)}}function l(i,a){let o=[];for(let e in i){let r=i[e],t={entityId:e,models:{}};for(let n in r){let[s,c]=n.split("-");if(!s||!c){a?.logging&&console.warn(`Invalid modelName format: ${n}`);continue}t.models[s]||(t.models[s]={}),t.models[s][c]=C(r[n])}o.push(t),a?.logging&&console.log("Parsed entity:",t)}return a?.logging&&console.log("Parsed result:",o),o}function S(i){switch(i.type){case"primitive":return i.value;case"struct":return C(i.value);case"enum":return i.value.option;case"array":return i.value.map(S);default:return i.value}}function C(i){let a=i instanceof Map?Array.from(i.entries()):Object.entries(i);return Object.fromEntries(a.map(([o,e])=>[o,S(e)]))}async function P(i,a,o,e,r=100,t=0,n){let s=T(a,o),c=t,y=!0,u={};for(;y;){let f={limit:r,offset:c,clause:s,dont_include_hashed_keys:!1};try{let d=await i.getEntities(f);n?.logging&&(console.log("Clause",s,"Query",a),console.log(`Fetched entities at offset ${c}:`,d)),Object.assign(u,d);let m=l(u);e({data:m}),Object.keys(d).length<r?y=!1:c+=r}catch(d){throw n?.logging&&console.error("Error fetching entities:",d),e({error:d}),d}}return n?.logging&&console.log("All fetched entities:",u),l(u)}async function Q(i,a,o,e,r=100,t=0,n){let s=T(a,o),c=t,y=!0,u={};for(;y;){let f={limit:r,offset:c,clause:s,dont_include_hashed_keys:!1};try{let d=await i.getEventMessages(f,!0);n?.logging&&console.log(`Fetched entities at offset ${c}:`,d),Object.assign(u,d);let m=l(u);e({data:m}),Object.keys(d).length<r?y=!1:c+=r}catch(d){throw n?.logging&&console.error("Error fetching entities:",d),e({error:d}),d}}return n?.logging&&console.log("All fetched entities:",u),l(u)}async function $(i,a,o,e,r){return r?.logging&&(console.log("Query:",a),console.log("convertQueryToEntityKeyClauses:",p(a,o))),i.onEntityUpdated(p(a,o),(t,n)=>{try{if(e){let s=l({[t]:n});r?.logging&&(console.log("Converted query to entity key clauses:",p(a,o)),console.log("Parsed entity data:",s)),e({data:s})}}catch(s){e&&(r?.logging&&console.error("Error parsing entity data:",s),e({error:s instanceof Error?s:new Error(String(s))}))}})}async function O(i,a,o,e,r){return i.onEventMessageUpdated(p(a,o),!0,(t,n)=>{try{if(e){let s=l({[t]:n});r?.logging&&console.log("Parsed entity data:",s),e({data:s})}}catch(s){e&&(r?.logging&&console.error("Error parsing entity data:",s),e({error:s instanceof Error?s:new Error(String(s))}))}})}import{create as R}from"zustand";import{immer as M}from"zustand/middleware/immer";import{applyPatches as A,produceWithPatches as k}from"immer";import{enablePatches as I}from"immer";import{subscribeWithSelector as F}from"zustand/middleware";I();function ue(){let i=R()(F(M((a,o)=>({entities:{},pendingTransactions:{},setEntities:e=>{a(r=>{e.forEach(t=>{r.entities[t.entityId]=t})})},updateEntity:e=>{a(r=>{if(e.entityId&&r.entities[e.entityId]&&e.models){let t=r.entities[e.entityId],n=Object.assign({},t.models);Object.entries(e.models).forEach(([s,c])=>{let y=s;y in n||(n[y]={}),n[y]=Object.assign({},n[y],c)}),r.entities[e.entityId]={...t,...e,models:n}}})},applyOptimisticUpdate:(e,r)=>{let t=o(),[n,s,c]=k(t,y=>{r(y)});a(()=>n),a(y=>{y.pendingTransactions[e]={transactionId:e,patches:s,inversePatches:c}})},revertOptimisticUpdate:e=>{let r=o().pendingTransactions[e];r&&(a(t=>A(t,r.inversePatches)),a(t=>{delete t.pendingTransactions[e]}))},confirmTransaction:e=>{a(r=>{delete r.pendingTransactions[e]})},subscribeToEntity:(e,r)=>i.subscribe(t=>{let n=t.entities[e];r(n)}),waitForEntityChange:(e,r,t=6e3)=>new Promise((n,s)=>{let c=i.subscribe(u=>u.entities[e],u=>{r(u)&&(clearTimeout(y),c(),n(u))}),y=setTimeout(()=>{c(),s(new Error(`waitForEntityChange: Timeout of ${t}ms exceeded`))},t)}),getEntity:e=>o().entities[e],getEntities:e=>{let r=Object.values(o().entities);return e?r.filter(e):r},getEntitiesByModel:(e,r)=>o().getEntities(t=>!!t.models[e]?.[r])}))));return i}async function z(i){return await v.createClient(i)}async function he(i,a){let o=await z(i.client);return{client:o,subscribeEntityQuery:(e,r,t)=>$(o,e,a,r,t),subscribeEventQuery:(e,r,t)=>O(o,e,a,r,t),getEntities:(e,r,t,n,s)=>P(o,e,a,r,t,n,s),getEventMessages:(e,r,t,n,s)=>Q(o,e,a,r,t,n,s),generateTypedData:(e,r,t=i.domain)=>({types:{StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],[e]:Object.keys(r).map(n=>({name:n,type:typeof r[n]=="bigint"||typeof r[n]=="number"?"felt":"string"}))},primaryType:e,domain:t,message:r}),sendMessage:async(e,r)=>{try{let t=await r.signMessage(e),n=JSON.stringify(e);await o.publishMessage(n,Array.isArray(t)?t:[t.r.toString(),t.s.toString()])}catch(t){throw console.error("Failed to send message:",t),t}}}}export{z as createClient,ue as createDojoStore,he as init};
//# sourceMappingURL=index.js.map