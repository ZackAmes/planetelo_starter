{"version":3,"sources":["../src/utils/index.ts","../src/game/simplex.ts"],"sourcesContent":["import {\n    Component,\n    Components,\n    ComponentValue,\n    Entity,\n    Type as RecsType,\n    Schema,\n    setComponent,\n} from \"@dojoengine/recs\";\nimport { poseidonHashMany } from \"micro-starknet\";\nimport { byteArray, ByteArray } from \"starknet\";\n\nconst STORE_SET_RECORD_EVENT_NAME =\n    \"0x1a2f334228cee715f1f0f54053bb6b5eac54fa336e0bc1aacf7516decb0471d\";\nconst TAG_SEPARATOR = \"-\";\n\n/**\n * Filters events from a given receipt based on specific criteria.\n *\n * @param {any} receipt - The transaction receipt.\n * @returns {any[]} An array of events that meet the filtering criteria.\n */\nexport function getEvents(receipt: any): any[] {\n    return receipt.events.filter((event: any) => {\n        return (\n            event.keys.length === 1 &&\n            event.keys[0] === STORE_SET_RECORD_EVENT_NAME\n        );\n    });\n}\n\n/**\n * Iterates over an array of events and updates components based on event data.\n *\n * @param {Components} components - The components to be updated.\n * @param {Event[]} events - An array of events containing component data.\n */\nexport function setComponentsFromEvents(components: Components, events: any[]) {\n    events.forEach((event) => setComponentFromEvent(components, event.data));\n}\n\n/**\n * Updates a component based on the data from a single event.\n *\n * @param {Components} components - The components to be updated.\n * @param {string[]} eventData - The data from a single event.\n */\nexport function setComponentFromEvent(\n    components: Components,\n    eventData: string[]\n) {\n    const componentNames = getComponentNames(components);\n    // retrieve the component name\n    try {\n        const componentName = getComponentNameFromEvent(\n            Array.from(componentNames.keys()),\n            eventData\n        );\n        // retrieve the component from name\n        const component =\n            components[componentNames.get(componentName) as string];\n\n        // get keys\n        const keysNumber = parseInt(eventData[1]);\n        let index = 2 + keysNumber + 1;\n\n        const keys = eventData\n            .slice(2, 2 + keysNumber)\n            .map((key) => BigInt(key));\n\n        // get entityIndex from keys\n        const entityIndex = getEntityIdFromKeys(keys);\n\n        // get values\n        const numberOfValues = parseInt(eventData[index]);\n\n        const string_keys = keys.map((key) => key.toString());\n\n        // get values\n        const values = eventData.slice(index, index + numberOfValues);\n\n        // create component object from values with schema\n        const componentValues = decodeComponent(component, [\n            ...string_keys,\n            ...values,\n        ]);\n\n        // set component\n        setComponent(component, entityIndex, componentValues);\n    } catch (error) {\n        console.log(error);\n    }\n}\n\n// Extract component names from components\nfunction getComponentNames(components: Components): Map<string, string> {\n    let names = new Map<string, string>();\n    for (const key of Object.keys(components)) {\n        const c: Component = components[key];\n        names.set(c.metadata?.name as string, key);\n    }\n    return names;\n}\n\n/**\n * Parse component value into typescript typed value\n *\n * @param {string} value - The value to parse\n * @param {RecsType} type - The target type\n */\nexport function parseComponentValue(value: string, type: RecsType) {\n    switch (type) {\n        case RecsType.Boolean:\n            return value === \"0x0\" ? false : true;\n        case RecsType.Number:\n            return Number(value);\n        case RecsType.BigInt:\n            return BigInt(value);\n        default:\n            return value;\n    }\n}\n\n/**\n * Decodes a component based on the provided schema.\n *\n * @param {Component} component - The component description created by defineComponent(), containing the schema and metadata types.\n * @param {string[]} values - An array of string values used to populate the decoded component.\n * @returns {Object} The decoded component object.\n */\nexport function decodeComponent(component: Component, values: string[]): any {\n    const schema: any = component.schema;\n    const types: string[] = (component.metadata?.types as string[]) ?? [];\n    const indices = { types: 0, values: 0 };\n    return decodeComponentValues(schema, types, values, indices);\n}\n\nfunction decodeComponentValues(\n    schema: Schema,\n    types: string[],\n    values: string[],\n    indices: any\n): any {\n    // Iterate through the keys of the schema and reduce them to build the decoded component.\n    return Object.keys(schema).reduce((acc: any, key) => {\n        const valueType = schema[key];\n        if (typeof valueType === \"object\") {\n            // valueType is a Schema\n            // it means it's a nested component. Therefore, we recursively decode it.\n            acc[key] = decodeComponentValues(\n                valueType as Schema,\n                types,\n                values,\n                indices\n            );\n        } else {\n            // valueType is a RecsType\n            // If the schema key points directly to a type or is not an object,\n            // we parse its value using the provided parseComponentValue function\n            // and move to the next index in the values array.\n            acc[key] = parseComponentValue(\n                values[indices.values],\n                valueType as RecsType\n            );\n            indices.values++;\n            // the u256 type in cairo is actually { low: u128, high: u128 }\n            // we need to consume two u128 values, shifting the second to compose u256\n            if (types[indices.types] == \"u256\") {\n                const value = parseComponentValue(\n                    values[indices.values],\n                    valueType as RecsType\n                ) as bigint;\n                acc[key] |= value << 128n;\n                indices.values++;\n            }\n            indices.types++;\n        }\n        return acc;\n    }, {});\n}\n\n/**\n * Converts a hexadecimal string to an ASCII string.\n */\nexport function hexToAscii(hex: string): string {\n    var str = \"\";\n    for (var n = 2; n < hex.length; n += 2) {\n        str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));\n    }\n    return str;\n}\n\n/**\n * Get the component name from felt event name\n */\nexport function getComponentNameFromEvent(\n    actions: string[],\n    event: string[]\n): string {\n    const actionFelt: Record<string, string> = actions.reduce(\n        (acc: Record<string, string>, action: string) => {\n            const parts = splitEventTag(action);\n            acc[getSelectorFromTag(parts[0], parts[1])] = action;\n            return acc;\n        },\n        {}\n    );\n    const eventName: string = event[0];\n    const action: string | undefined = actionFelt[eventName];\n    if (!action) {\n        throw new Error(\n            `Action ${eventName} not found in actions : ${actions}`\n        );\n    }\n    return action;\n}\n\n// Encodes big number to formatted hex string\nfunction toHexString(bn: bigint): string {\n    return \"0x\" + bn.toString(16);\n}\n\n// Computes dojo selector from namespace and event name\nexport function getSelectorFromTag(namespace: string, event: string): string {\n    return toHexString(\n        poseidonHashMany([\n            computeByteArrayHash(namespace),\n            computeByteArrayHash(event),\n        ])\n    );\n}\n\n// Serializes a ByteArray to a bigint array\nfunction serializeByteArray(byteArray: ByteArray): bigint[] {\n    const result: bigint[] = [\n        BigInt(byteArray.data.length),\n        ...byteArray.data.map((word) => BigInt(word.toString())),\n        BigInt(byteArray.pending_word),\n        BigInt(byteArray.pending_word_len),\n    ];\n    return result;\n}\n\n// Poseidon hash of a string representated as a ByteArray\nexport function computeByteArrayHash(str: string): bigint {\n    const bytes = byteArray.byteArrayFromString(str);\n    return poseidonHashMany(serializeByteArray(bytes));\n}\n\n// Splits selector name into namespace and event name\nexport function splitEventTag(event: string): string[] {\n    return event.split(TAG_SEPARATOR);\n}\n\n/**\n * Determines the entity ID from an array of keys. If only one key is provided,\n * it's directly used as the entity ID. Otherwise, a poseidon hash of the keys is calculated.\n *\n * @param {bigint[]} keys - An array of big integer keys.\n * @returns {Entity} The determined entity ID.\n */\nexport function getEntityIdFromKeys(keys: bigint[]): Entity {\n    // if (keys.length === 1) {\n    //     return (\"0x\" + keys[0].toString(16)) as Entity;\n    // }\n    // calculate the poseidon hash of the keys\n    let poseidon = poseidonHashMany(keys);\n    return (\"0x\" + poseidon.toString(16)) as Entity;\n}\n\n/**\n * Iterate through GraphQL entities and set components based on them.\n *\n * @param {Components} components - The target components structure where the parsed data will be set.\n * @param {any[]} entities - The array of GraphQL entities to parse and set in the components.\n */\nexport function setComponentsFromGraphQLEntities(\n    components: Components,\n    entities: any\n) {\n    entities.forEach((entity: any) => {\n        setComponentFromGraphQLEntity(components, entity);\n    });\n}\n\n/**\n * Set a component from a single GraphQL entity.\n *\n * @param {Components} components - The target components structure where the parsed data will be set.\n * @param {any} entityEdge - The GraphQL entity containing node information to parse and set in the components.\n */\nexport function setComponentFromGraphQLEntity(\n    components: Components,\n    entityEdge: any\n) {\n    const keys = entityEdge.node.keys.map((key: string) => BigInt(key));\n    const entityIndex = getEntityIdFromKeys(keys);\n\n    entityEdge.node.models.forEach((model: any) => {\n        const componentName = model.__typename;\n        const component = components[componentName];\n\n        if (!component) {\n            console.error(`Component ${componentName} not found`);\n            return;\n        }\n\n        const componentValues = Object.keys(component.schema).reduce(\n            (acc: ComponentValue, key) => {\n                const value = model[key];\n                const parsedValue = parseComponentValueFromGraphQLEntity(\n                    value,\n                    component.schema[key]\n                );\n                acc[key] = parsedValue;\n                return acc;\n            },\n            {}\n        );\n\n        setComponent(component, entityIndex, componentValues);\n    });\n}\n\n/**\n * Parse a component's value from a GraphQL entity based on its type or schema.\n *\n * @param {any} value - The raw value from the GraphQL entity.\n * @param {RecsType | object} type - The expected type or schema for the value.\n * @returns {any} The parsed value.\n */\nexport function parseComponentValueFromGraphQLEntity(\n    value: any,\n    type: RecsType | object\n): any {\n    if (value === undefined || value === null) return value;\n\n    // Check if type is an object (i.e., a nested schema)\n    if (typeof type === \"object\" && type !== null) {\n        const parsedObject: any = {};\n        for (const key in type) {\n            parsedObject[key] = parseComponentValueFromGraphQLEntity(\n                value[key],\n                (type as any)[key]\n            );\n        }\n        return parsedObject;\n    }\n\n    // For primitive types\n    switch (type) {\n        case RecsType.Boolean:\n            return !!value;\n        case RecsType.Number:\n            if (typeof value === \"string\") {\n                return 0;\n            }\n            return !isNaN(Number(value)) ? Number(value) : value;\n        case RecsType.BigInt:\n            return BigInt(value);\n        default:\n            return value;\n    }\n}\n\nexport function shortenHex(hexString: string, numDigits = 6) {\n    if (hexString?.length <= numDigits) {\n        return hexString;\n    }\n\n    const halfDigits = Math.floor(numDigits / 2);\n    const firstHalf = hexString.slice(0, halfDigits);\n    const secondHalf = hexString.slice(-halfDigits);\n    return `${firstHalf}...${secondHalf}`;\n}\n","import * as math from \"mathjs\";\n\nconst multiply = (a: any, b: any) => {\n    if (!Array.isArray(a) || !Array.isArray(b)) return math.multiply(a, b);\n    return a.map((v, i) => v * b[i]);\n};\n\nconst floor = (a: any) => {\n    return a.map((v: any) => Math.floor(v));\n};\n\nconst step = (a: any, b: any) => {\n    return a.map((v: any, i: any) => (b[i] <= v ? 0 : 1));\n};\n\nconst mod289 = (x: any) => {\n    return x.map((v: any) => v - Math.floor(v * (1.0 / 289.0)) * 289.0);\n};\n\nconst permute = (x: any) => {\n    x = x.map((v: any) => (v * 34.0 + 1.0) * v);\n    return mod289(x);\n};\n\nconst taylorInvSqrt = (r: any) => {\n    return r.map((v: any) => 1.79284291400159 - 0.85373472095314 * v);\n};\n\nexport const snoise = (v: any) => {\n    const C = [1.0 / 6.0, 1.0 / 3.0];\n    const D = [0.0, 0.5, 1.0, 2.0];\n\n    // First corner\n    let i = floor(math.add(v, math.dot(v, [C[1], C[1], C[1]])));\n    let x0 = math.add(math.subtract(v, i), math.dot(i, [C[0], C[0], C[0]]));\n\n    // Other corners\n    let g = step([x0[1], x0[2], x0[0]], [x0[0], x0[1], x0[2]]);\n    let l = math.subtract(1.0, g);\n    let i1 = math.min(\n        [\n            [g[0], g[1], g[2]],\n            [l[2], l[0], l[1]],\n        ],\n        0\n    );\n    let i2 = math.max(\n        [\n            [g[0], g[1], g[2]],\n            [l[2], l[0], l[1]],\n        ],\n        0\n    );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    let x1 = math.add(math.subtract(x0, i1), [C[0], C[0], C[0]]);\n    let x2 = math.add(math.subtract(x0, i2), [C[1], C[1], C[1]]); // 2.0*C.x = 1/3 = C.y\n    let x3 = math.subtract(x0, [D[1], D[1], D[1]]); // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    let p1 = permute(math.add(i[2], [0.0, i1[2], i2[2], 1.0]));\n    let p2 = permute(math.add(math.add(p1, i[1]), [0.0, i1[1], i2[1], 1.0]));\n    let p = permute(math.add(math.add(p2, i[0]), [0.0, i1[0], i2[0], 1.0]));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    let ns = [0.285714285714286, -0.928571428571428, 0.142857142857143]; // these must be *exact*\n    let j = math.subtract(p, multiply(49, floor(multiply(p, ns[2] * ns[2])))); //  mod(p,7*7)\n\n    let x_ = floor(multiply(j, ns[2]));\n    let y_ = floor(math.subtract(j, multiply(7, x_))); // mod(j,N)\n\n    let x = math.add(multiply(x_, ns[0]), [ns[1], ns[1], ns[1], ns[1]]);\n    let y = math.add(multiply(y_, ns[0]), [ns[1], ns[1], ns[1], ns[1]]);\n    let h = math.subtract(math.subtract(1.0, math.abs(x)), math.abs(y));\n\n    let b0 = [x[0], x[1], y[0], y[1]];\n    let b1 = [x[2], x[3], y[2], y[3]];\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    let s0 = math.add(multiply(floor(b0), 2.0), 1.0);\n    let s1 = math.add(multiply(floor(b1), 2.0), 1.0);\n    let sh = multiply(-1, step(h, [0, 0, 0, 0]));\n\n    let a0 = math.add(\n        [b0[0], b0[2], b0[1], b0[3]],\n        multiply([s0[0], s0[2], s0[1], s0[3]], [sh[0], sh[0], sh[1], sh[1]])\n    );\n    let a1 = math.add(\n        [b1[0], b1[2], b1[1], b1[3]],\n        multiply([s1[0], s1[2], s1[1], s1[3]], [sh[2], sh[2], sh[3], sh[3]])\n    );\n\n    let p0 = [a0[0], a0[1], h[0]];\n    p1 = [a0[2], a0[3], h[1]];\n    p2 = [a1[0], a1[1], h[2]];\n    let p3 = [a1[2], a1[3], h[3]];\n\n    // Normalise gradients\n    let norm = taylorInvSqrt([\n        math.dot(p0, p0),\n        math.dot(p1, p1),\n        math.dot(p2, p2),\n        math.dot(p3, p3),\n    ]);\n    p0 = multiply(p0, norm[0]);\n    p1 = multiply(p1, norm[1]);\n    p2 = multiply(p2, norm[2]);\n    p3 = multiply(p3, norm[3]);\n\n    // Mix final noise value\n    //@ts-ignore\n    let m = math.max(\n        [\n            //@ts-ignore\n            math.subtract(0.5, [\n                math.dot(x0, x0),\n                math.dot(x1, x1),\n                math.dot(x2, x2),\n                math.dot(x3, x3),\n            ]),\n            [0, 0, 0, 0],\n        ],\n        0\n    );\n    m = multiply(m, m);\n    m = multiply(m, m);\n    let noise = multiply(\n        105.0,\n        //@ts-ignore\n        math.dot(m, [\n            math.dot(p0, x0),\n            math.dot(p1, x1),\n            math.dot(p2, x2),\n            math.dot(p3, x3),\n        ])\n    );\n    return noise;\n};\n\nexport const recursiveSNoise = (p: any, pers: any, octaves: any) => {\n    let total = 0.0;\n    let frequency = 1.0;\n    let amplitude = 1.0;\n    let maxValue = 0.0;\n\n    for (let i = 0; i < octaves; i++) {\n        total += snoise(multiply(p, frequency)) * amplitude;\n        maxValue += amplitude;\n        amplitude *= pers;\n        frequency *= 2.0;\n    }\n\n    const noise = total / maxValue;\n    return noise;\n};\n\nexport default {\n    snoise,\n    recursiveSNoise,\n};\n"],"mappings":"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","names":["RecsType","setComponent","poseidonHashMany","byteArray","STORE_SET_RECORD_EVENT_NAME","TAG_SEPARATOR","getEvents","receipt","event","setComponentsFromEvents","components","events","setComponentFromEvent","eventData","componentNames","getComponentNames","componentName","getComponentNameFromEvent","component","keysNumber","index","keys","key","entityIndex","getEntityIdFromKeys","numberOfValues","string_keys","values","componentValues","decodeComponent","error","names","c","parseComponentValue","value","type","schema","types","decodeComponentValues","indices","acc","valueType","hexToAscii","hex","str","n","actions","actionFelt","action","parts","splitEventTag","getSelectorFromTag","eventName","toHexString","bn","namespace","computeByteArrayHash","serializeByteArray","word","bytes","setComponentsFromGraphQLEntities","entities","entity","setComponentFromGraphQLEntity","entityEdge","model","parsedValue","parseComponentValueFromGraphQLEntity","parsedObject","shortenHex","hexString","numDigits","halfDigits","firstHalf","secondHalf","math","multiply","a","b","v","i","floor","step","mod289","x","permute","taylorInvSqrt","r","snoise","C","D","x0","g","l","i1","i2","x1","x2","x3","p1","p2","p","ns","j","x_","y_","y","h","b0","b1","s0","s1","sh","a0","a1","p0","p3","norm","m","recursiveSNoise","pers","octaves","total","frequency","amplitude","maxValue"]}